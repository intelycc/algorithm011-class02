### 高级动态规划
#### 动态规划要点
这里复习下动态规划的要点及解题标准步骤
**关键词：**
1. 分治
2. 最优子结构
3. 动态递推
4. 一般找最优解的可以先考虑是否能用dp来解决
5. 多练、数学、逻辑思维

**步骤：**
1. 定义状态，不同的状态定义会导致不同的dp方程，所以状态定义很重要。根据题目场景可以考虑一维、二维、三维、甚至更多维数，有些一目了然，有些则要花点心思
2. 定义状态转移方程：此处也是难点，要善于发现规律，使用数学归纳法一步步推导，先找出最优子问题，然后根据最优子问题能够推导处当前问题的最优解
3. 初始条件：状态转移要从一个边界情况（basecase）开始一步步递推，所以会有basecase的初始化，此处要考虑充分，有些比较难的题目容易漏掉。可以结合图形，如二维矩阵来理解
4. 压缩状态：这个是优化，可选步骤。因为有些状态转移方程只来源于前置条件，所以不需要把所有状态都保存下来，只需要保存前置需要的，然后不断替换。这样写出来的代码乍一看会比较难理解，但是其实是从标准动态规划优化而来的，可以减少空间复杂度
##### DP顺推模板
```
function DP()
 dp = [][] #二维情况
 
 for i = 0...M {
   for j = 0...N {
      dp[i][j] = _Function(dp[i`][j`]...)
   }
 }
 return dp[M][N];
```
#### 题目：不同路径2
##### 思考
此题考虑用动态规划来解决，那么按照动态规划的接替套路走：
1. 定义状态：因为机器人所走的平面是二维的，所以首先想到用二维dp数组来表示状态，那么自然想到dp[i][j]代表平面上的坐标(i，j)到终点的不同路径数，可以先用此状态定义推导下转移方程看看是否合适
2. 状态转移方程：因为只能向下或者向右行走，所以(i,j)只可能走向(i+1，j)或 (i, j+ 1)，那么(i,j)到终点的路径数即等于(i+1，j)和 (i, j+ 1)之和
所以动态转移方程也出来了:
dp[i][j] = dp[i+1][j] + dp[i][j+1]
但是此题在平面上有障碍，所以有障碍的点是无法到达终点的，dp[i][j] = 0 。所以完整的dp方程式：
obstacleGrid[i][j] == 1时  dp[i][j] = 0 
obstacleGrid[i][j] == 0时 dp[i][j] = dp[i+1][j] + dp[i][j+1]
3. Basecase：接下来就是要考虑初始情况，一个是i == rows - 1，一个是j == cols - 1，即最后一行，和最后一列，这些单元格的路径只能来源一个方向，即下或者右。
还有就是不要忽略了终点，终点是没有路径来源的，比较特殊，当终点为障碍物的时候dp[rows - 1][cols - 1] = 0, 不为障碍物的时候为 dp[rows - 1][cols - 1] = 1

##### 代码
```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        if (obstacleGrid == null || obstacleGrid.length == 0 || obstacleGrid[0].length == 0) return 0;
        int rows = obstacleGrid.length;
        int cols = obstacleGrid[0].length;
        int[][] dp = new int[rows][cols];
        for (int i = rows - 1; i >= 0; i--) {
            for (int j = cols - 1; j >= 0; j--) {
                //如果当前是障碍物，则不用计算；遇到终点，也可以跳过
                if (obstacleGrid[i][j] == 1) {
                    continue;
                }
                if (i == rows - 1) {
                    dp[i][j] = j + 1 < cols ?dp[i][j + 1] : 1;//basecase
                } else if (j == cols - 1) {
                    dp[i][j] = i + 1 < rows ? dp[i + 1][j] : 1;//basecase
                } else {
                    dp[i][j] = dp[i + 1][j] + dp[i][j + 1];
                }
            }
        }
        return dp[0][0];
    }
}
```
### 字符串匹配算法
#### 暴力法
遍历主串，主串每次右移一个位置；每次遍历中和模式串进行逐个匹配，时间复杂度是O(m * n)，n是主串长度，m是模式串长度
#### Rabin-Karp算法
在暴力法的基础上演进，通过比较子串的哈希值和模式串是否一样来判断，如果不一样则跳过，如果一样则需要继续逐个比对看是否一样，最好情况是O(n)，最坏情况O(m * n)
#### KMP算法
对暴力法的优化，在匹配过程中遇到那些不可匹配的字符的时候，希望用某些规律将模式串右滑多几位，跳过那些肯定不会匹配的情况，时间复杂度O(m+n)